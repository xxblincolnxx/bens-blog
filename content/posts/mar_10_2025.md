+++
date = '2025-03-10T13:23:37-04:00'
draft = false
author = 'Ben Prothe'
title = 'Auth with Drizzle, NestJS, and Passport'
series = "Final Project Rebuild"
tags = ['NestJS', 'Drizzle', 'Passport.js','Auth']
+++

Here I'll record the steps involved in setting up Passport with Drizzle and NestJS using Local and JWT strategies.

### Installation

**Before you start**: Need an existing NestJS project with Drizzle set up with database module.

Validation Dependencies:

- `npm i class-validator class-transformer`

Passport Dependencies:

- `npm i @nestjs/passport passport passport-local passport-jwt`
- `npm i @nestjs/jwt`
- `npm i @types/passport-jwt @types/passport-local`

### Users Module

We first need to set up a table in the database where the user information will be persisted.

1. Run the following to generate required files for User model:
   - `nest g module users`
   - `nest g controller users`
   - `nest g service users`
2. Create schema file and configure columns:

```ts
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: text('email').unique().notNull(),
  password: text('password').notNull(),
});
```

3. Configure `users.module.ts`:

```ts
@Module({
  imports: [DatabaseModule],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

4. Configure `users.service.ts`:

```ts
import * as schema from './schema';
@Injectable()
export class UsersService {
  constructor(
    @Inject(DATABASE_CONNECTION)
    private readonly database: NodePgDatabase<typeof schema>
  ) {}
}
```

5. Add the following line to `main.ts` to enable validators in the DTO:

```ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe()); // THIS IS NEW
  await app.listen(process.env.PORT ?? 3000);
}
```

6. Create request DTO for `create-user.request.ts` with validators :

```ts
import { IsEmail, IsStrongPassword } from 'class-validator';
export class CreateUserRequest {
  @IsEmail()
  email: string;

  @IsStrongPassword()
  password: string;
}
```

7. Add "Post" method to `users.controller.ts`:

```ts
@Post()
async  createUser(@Body() request:  CreateUserRequest) {
	return  this.usersService.createUser(request);
}
```

8. Add "createUser()" method to `users.service.ts` and hash the password (don't store as plain text):
   - Install bcrypt: `npm i bcryptjs @types/bcryptjs`

```ts
async  createUser(user:  typeof schema.users.$inferInsert) {
	const  hashedPassword  =  await  hash(user.password ||  '',  10);
	await  this.database.insert(schema.users).values({ ...user,  password:  hashedPassword });
}
```

### Setting up Passport.js

1. Create Auth Module:

- `nest g module auth`
- `nest g controller auth`
- `nest g service auth`

2. Configure `auth.module.ts`:

```ts
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';

@Module({
  imports: [UsersModule, PassportModule, JwtModule],
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
```

3. Add "UsersService" to exports of the `users.module.ts`
4. Create `auth/strategies` directory
5. Create a new file `local.strategy.ts` and export an injectable class as follows:

```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      usernameField: 'email',
    });
  }
  async validate(email: string, password: string) {
    // WE'LL ABSTRACT THIS INTO auth.service.ts
  }
}
```

6. Create `getUser()` method for `users.service.ts`:

```ts
async  getUser(email:  string) {
const  user  =  await  this.database.query.users.findMany({
	where:  eq(schema.users.email,  email),
}); // Returns an array of matches

if (user.length < 1) {
	throw  new  NotFoundException('User not found');
}
return  user[0];
}
```

7. Inject UsersService and add logic to verify user in `auth.service.ts`:

```ts
export class AuthService {
  constructor(private readonly usersService: UsersService) {}
  async verifyUser(email: string, password: string) {
    try {
      const user = await this.usersService.getUser(email);
      const authenticated = await compare(password, user.password);
      if (!authenticated) {
        throw new UnauthorizedException();
      }
      return user;
    } catch (error) {
      throw new UnauthorizedException(error);
    }
  }
}
```

8. Go back to `local.strategy.ts` and add call to verifyUser(). Note: Everything we return here will be added to the request object under the user property allowing us to access the user from the request object in any service layer.

```ts
async  validate(email:  string,  password:  string) {
	return  this.authService.verifyUser(email,  password);
}
```

9. Add `LocalStrategy` to providers array inside `auth.module.ts`
10. Create `auth/guards` directory and create `local-auth.guard.ts`. Each strategy will get a guard file.

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}
```

11. Add `@Post` route to `auth.controller.ts`:

```ts
import { Controller, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from './guards/local-auth.guard';

@Controller('auth')
export class AuthController {
  @Post('login')
  @UseGuards(LocalAuthGuard)
  async login() {
    // This is where we'll create a JWT token and return it to the client. It will then use JWT to authenticate itself in future requests.
  }
}
```

NOTE: Its important that the JWT is not accessible via client-side JS so we're going to have it saved onto a HTTP only cookie that accompanies every request.

### Creating the login route and JWT

1. First we'll abstract the ability to extract the "user" information from the the request object. Create `auth/current-user.decorator.ts`:

```ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '../users/dto/create-user.request';

const getCurrentUserByContext = (context: ExecutionContext): User =>
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
  context.switchToHttp().getRequest().user;

export const CurrentUser = createParamDecorator<User>(
  (_data: unknown, context: ExecutionContext) =>
    getCurrentUserByContext(context)
);
```

3. Add new env variable for `JWT_ACCESS_TOKEN_SECRET`. Create a secure value [here](https://randomkeygen.com/). Use the "CodeIgniter Encryption Keys" option.
4. Create env variable for `JWT_ACCESS_TOKEN_EXPIRATION_MS` and set to 3600000
5. Inject `ConfigService` and `JwtService` into AuthService class.
6. Create interface for TokenPayload:

```ts
export interface TokenPayload {
  userId: string;
}
```

8. Add login() method to AuthService:

```ts
async  login(user:  User,  response:  Response) {
	const  expiresTime  =  new  Date();
	expiresTime.setMilliseconds(
		expiresTime.getTime() +
			parseInt(this.configService.getOrThrow<string>('JWT_ACCESS_TOKEN_EXPIRATION_MS'),
		),
	);

	const  tokenPayload:  TokenPayload  = {
		userId:  user.id.toString(),
	};

	const  accessToken  =  this.jwtService.sign(tokenPayload, {
		secret:  this.configService.getOrThrow<string>('JWT_ACCESS_TOKEN_SECRET'),
		expiresIn:  `${this.configService.getOrThrow('JWT_ACCESS_TOKEN_EXPIRATION_MS')}ms`,
	});

	response.cookie('Authentication',  accessToken, {
		httpOnly:  true,
		secure:  this.configService.get('NODE_ENV') ===  'production',
		expires:  expiresTime,
	});
}
```

8. Add `UsersService` to exports array for `users.module.ts` and providers array for `app.module.ts`

### Using JWT to guard endpoints

1. Add "cookie-parser" as middleware in `main.ts`. This will parse the cookie for every request and append it to the "request" object:

```ts
import * as cookieParser from 'cookie-parser'; // The "* as" is important

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  app.use(cookieParser()); // Here's the new line
  await app.listen(process.env.PORT ?? 3000);
}
```

2. Create `auth/strategies/jwt.strategy.ts`

```ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    configService: ConfigService,
    private readonly usersService: UsersService
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (request: Request) => request.cookies?.Authentication,
      ]),
      secretOrKey: configService.getOrThrow('JWT_ACCESS_TOKEN_SECRET'),
    });
  }

  async validate(payload: TokenPayload) {
    return this.usersService.getUser({ email: null, id: payload.userId });
  }
}
```

3. I had to reconfigure `usersService.getUser()` to be able to query a user with either an email or an id.
4. Add `JwtStrategy` to "providers" array in side of `auth.module.ts`
5. Create `auth/guards/jwt-auth.guard.ts`:

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

6. The following is an example of an end point that utilizes the guard we just created as well as the `@CurrentUser()` decorator.

```ts
// users.service.ts - This method retrieves the menus associated with the currently logged in user:
async  getUserMenus(user:  User) {
	return  this.database.query.users.findFirst({
		where:  eq(schema.users.email,  user.email),
		with: {
			menus:  true,
		},
	});
}

// users.controller.ts - @CurrentUser() extracts the user object from the request object
// the JwtAuthGuard validates the JWT attached to the request and either throws an error or allows the request to proceed.
@Get('menus')
@UseGuards(JwtAuthGuard)
async  getUserMenus(@CurrentUser() user:  User) {
	return  this.usersService.getUserMenus(user);
}
```
